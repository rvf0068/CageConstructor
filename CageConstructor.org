#+TITLE: Newcages

* Notes

** misc

- Currently the program can find sucessfully cubic graphs with excess
  and small girth.

- (26,7,3) is a nice test case, in 3 tries, the first took more than
  300, the second and third between 200 and 300.

** tests

- (34,8,3), limit=500

| OneEdgeF/EdgesF | 0(Random)         | 1(OldAndRandom)   | 2(OldAndRandomNRD) | 3(AlternateDM) |
|-----------------+-------------------+-------------------+--------------------+----------------|
| 0(First)        | -,-,- (stop)      | -,-,- (stop)      | -,-,- (stop)       | -,-,- (stop)   |
| 1(DegreeSumMax) | -,-,- (stop)      | -,-,-,-,-         | -,-,-,-,-          | -,-,-,-,-      |
| 2(DSMNotRecent) | 211,-,236,481,377 | -,449,185,114,433 | -,129,-,270,497    | -,-,414,433,-  |
| 3(DSMNJRemoved) | 23,-,-,199,-      | -,-,-,287,43      | 249,303,288,152,-  | -,-,-,-,-      |

* todo

- [ ] define a cycle as an XGraph, so that we start looking for a cage
  from there (note that many cages are hamiltonian).

- [ ] split the code in modules, for example one for cages and one for
  the core.

- [ ] repeat the tests (only with the best algorithm), with (30,5,5)
  and limit 500, but this time recording how many different graphs up
  to isomorphism were obtained. 

- [X] age can be measured with the ntry the edge was introduced, just
  like 'whendeleted'.

- [-] print more information, maybe in a temp .txt file, for example:
  - [X] how many feasible edges to choose from
  - [ ] the score to decide to add, or delete an edge
  - [X] whether the edges added equal the edges removed, and how many
    times this has happened.
  - [X] how many vertices have the 'wrong' degree, with the count of
    each such wrong degree.
  - [ ] Example: report:
#+begin_example
2392
[0, 0, 0, 2, 4, 26]
Removing  (25, 30)
Removing  (26, 28)
Adding  (26, 28) out of 2
Adding  (25, 30) out of 1
Same as the previous graph
2393
[0, 0, 0, 2, 4, 26]
Removing  (10, 29)
Removing  (18, 22)
Removing  (18, 26)
Adding  (10, 29) out of 4
Adding  (11, 18) out of 3
Adding  (18, 22) out of 1
New graph!. There are now 617 graphs
2394
[0, 0, 0, 2, 4, 26]
Removing  (7, 24)
Adding  (7, 14) out of 2
New graph!. There are now 618 graphs
#+end_example
  with something like:    
#+begin_example
.
617: [0, 0, 0, 2, 4, 26]
618: [0, 0, 0, 2, 4, 26]
#+end_example
i.e., a dot for each repeated graph, and the degree histogram for a
new graph.

- [ ] define the small cages (and maybe the graphs with small excess)
  so that one can compare results)

- [ ] send email (optionally) when SearchForGraph finishes

- [X] define a pos dictionary for trees, for making pictures of the
  graphs produced

- [ ] make a table of tests

- [X] implement (as an option) that all edges returned in the same try
  have age equal to 1, and the rest have their age incremented only
  by 1. Currently, if the edges e1, e2 are added, e1 will have age 2,
  e2 will have age 1, and the rest have their age added by 3.

- [X] keep a list of the graphs produced, classified up to isomorphism.

- [ ] Maybe keep 'score' of an edge as an attribute. An edge with a
  high score would be less likely to be removed. For example, if one
  edge were removed and such edge were the only possible edge to add,
  such edge would have a high score. If before adding an edge there
  were many chanches, and after adding it were much less, such an edge
  would be 'bad'.

- [ ] Define the functions relative to each problem in a separate
  file, and load them as needed.
